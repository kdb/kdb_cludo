<?php

/**
 * @file
 * Integration with Cludo search.
 */

use Drupal\Core\Url;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\dpl_search\DplSearchSettings;
use Drupal\drupal_typed\DrupalTyped;
use Drupal\file\FileInterface;
use Drupal\image\Entity\ImageStyle;
use Drupal\kdb_cludo\CludoProfile;
use Drupal\kdb_cludo\Services\CludoProfileService;
use Drupal\media\MediaInterface;

/**
 * Getting the teaser-list image of an entity as a Cludo-readable metatag.
 *
 * @param \Drupal\Core\Entity\FieldableEntityInterface $entity
 *   The entity we're looking up.
 * @param string $field_name
 *   The field name of the teaser image field.
 * @param string $metatag_key
 *   The key that will be used as the metatag key.
 *
 * @return array<mixed>|null
 *   A meta-tag render array, ready to be used in #attached.
 */
function _kdb_cludo_get_image_metatag(FieldableEntityInterface $entity, string $field_name, string $metatag_key): ?array {
  $image_style_id = 'list_teaser_4_3';

  if (!$entity->hasField($field_name)) {
    return NULL;
  }

  $teaser_medias = $entity->get($field_name)->referencedEntities();
  $teaser_media = reset($teaser_medias);

  if (!($teaser_media instanceof MediaInterface) ||
    !$teaser_media->hasField('field_media_image') ||
    $teaser_media->get('field_media_image')->isEmpty()) {
    return NULL;
  }

  $file = $teaser_media->get('field_media_image')->entity;

  if (!($file instanceof FileInterface)) {
    return NULL;
  }

  $file_uri = $file->getFileUri();
  $image_style = ImageStyle::load($image_style_id);

  if (!($image_style instanceof ImageStyle) || !$file_uri) {
    return NULL;
  }

  return [
    '#tag' => 'meta',
    '#attributes' => [
      'name' => $metatag_key,
      'content' => $image_style->buildUrl($file_uri),
    ],
  ];
}

/**
 * Getting reference-field labels, as metatags.
 *
 * This is useful for stuff such as tags and categories, to expose to Cludo.
 *
 * @param \Drupal\Core\Entity\FieldableEntityInterface $entity
 *   The entity we're looking up.
 * @param string $field_name
 *   The field name of the reference field.
 * @param string $metatag_key
 *   The key that will be used as the metatag key.
 *
 * @return array<mixed>|null
 *   A meta-tag render array, ready to be used in #attached.
 */
function _kdb_cludo_get_reference_label_metatag(FieldableEntityInterface $entity, string $field_name, string $metatag_key): ?array {
  if (!$entity->hasField($field_name) || $entity->get($field_name)->isEmpty()) {
    return NULL;
  }

  $field = $entity->get($field_name);

  $references = $field->referencedEntities();
  $labels = [];

  foreach ($references as $reference) {
    if (!($reference instanceof FieldableEntityInterface)) {
      continue;
    }

    $label = $reference->label();

    if (!empty($label)) {
      $labels[] = $label;
    }
  }

  if (empty($labels)) {
    return NULL;
  }

  return [
    '#tag' => 'meta',
    '#attributes' => [
      'name' => $metatag_key,
      'content' => implode(', ', $labels),
    ],
  ];
}

/**
 * Implements hook_page_attachments().
 *
 * Adds custom metatag to node and event pages, to expose data as metatags, for
 * Cludo search to use in their results.
 */
function kdb_cludo_page_attachments(array &$page): void {
  $route = \Drupal::routeMatch();
  $branch_field_name = 'field_branch';
  $categories_field_name = 'field_categories';
  $tags_field_name = 'field_tags';
  $image_field_name = 'field_teaser_image';

  switch ($route->getRouteName()) {
    case 'entity.node.canonical':
      $entity = $route->getParameter('node');
      break;

    case 'entity.eventseries.canonical':
      $entity = $route->getParameter('eventseries');
      break;

    case 'entity.eventinstance.canonical':
      $entity = $route->getParameter('eventinstance');
      $branch_field_name = 'branch';
      $categories_field_name = 'event_categories';
      $tags_field_name = 'event_tags';
      $image_field_name = 'event_teaser_image';
      break;

    default:
      return;
  }

  $reference_fields = [
    'branch' => $branch_field_name,
    'categories' => $categories_field_name,
    'tags' => $tags_field_name,
  ];

  foreach ($reference_fields as $key => $field_name) {
    $reference_metatag = _kdb_cludo_get_reference_label_metatag($entity, $field_name, $key);

    if ($reference_metatag) {
      $page['#attached']['html_head'][] = [$reference_metatag, $key];
    }
  }

  $image_metatag_key = 'teaserImage';
  $image_metatag = _kdb_cludo_get_image_metatag($entity, $image_field_name, $image_metatag_key);

  if ($image_metatag) {
    $page['#attached']['html_head'][] = [$image_metatag, $image_metatag_key];
  }

}

/**
 * Implements template_preprocess_page().
 *
 * If we are on a Cludo-search page, we replace the material search
 * toolbar with the cludo auto-complete form.
 * That way, the user can see and change their fulltext search in the header.
 */
function kdb_cludo_preprocess_page(array &$variables): void {
  $route_name = \Drupal::routeMatch()->getRouteName();

  // Let's do a simple check first, to avoid a somewhat-heavy look up on
  // every single route.
  if (!$route_name || !str_starts_with($route_name, 'kdb_cludo.search_page')) {
    return;
  }

  $variables['search']['header'] = [
    '#theme' => 'kdb_cludo_search_header',
    '#default_input' => \Drupal::request()->query->get('cludoquery'),
    '#label' => t('Search', [], ['context' => 'kdb_cludo']),
  ];

  $service = DrupalTyped::service(CludoProfileService::class, 'kdb_cludo.cludo_profile');
  $profile = $service->getProfileByValue($route_name, 'cludoRouteName');

  if (!$profile) {
    return;
  }

  $config = $profile->getConfigSettings();

  $variables['search']['header']['#label'] = $config['input_placeholder'] ?? NULL;
}

/**
 * Implements hook_preprocess().
 *
 * Add a link to the editorial web search, on the material search page,
 * if we find any results from the search string query.
 */
function kdb_cludo_preprocess_dpl_react_app(array &$variables): void {
  $name = $variables['name'] ?? NULL;

  if ($name !== 'search-result') {
    return;
  }

  $variables['#cache']['tags'][] = 'kdb_cludo';

  // Getting the input that was material-searched for.
  $input = \Drupal::request()->query->get(DplSearchSettings::MATERIAL_QUERY_KEY);

  if (empty($input) || !is_string($input)) {
    return;
  }

  $input = urldecode($input);

  $profileService = DrupalTyped::service(CludoProfileService::class, 'kdb_cludo.cludo_profile');
  $profile = $profileService->getProfileByValue('main');

  if (!$profile) {
    return;
  }

  $config = $profile->getConfigSettings();
  $enabled = $config['enabled'] ?? NULL;

  if (!$enabled) {
    return;
  }

  $url = $profile->getCludoUrl();

  if ($url instanceof Url) {
    $url->setAbsolute(TRUE);

    $apiService = DrupalTyped::service(CludoApiService::class, 'kdb_cludo.cludo_api');
    $apiService->setProfile($profile);

    $variables['attributes']['data-web-search-config'] = Safe\json_encode([
      'webSearchText' => $input,
      'webSearchUrl' => $url->toString() . "#?cludoquery=$input",
      'hasWebSearchResults' => TRUE,
      // @todo get total from Cludo API lookup.
      'webSearchTotal' => NULL,
    ]);
  }
}
/**
 * Implements hook_theme().
 */
function kdb_cludo_theme(array $existing, string $type, string $theme, string $path): array {
  return [
    'kdb_cludo_search_page' => [
      'variables' => [
        'title' => NULL,
    'kdb_cludo_search_header' => [
      'variables' => [
        'label' => t('Search content', [], ['context' => 'kdb_cludo']),
        'default_input' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_module_implements_alter().
 *
 * Make sure the page_process happens last, after any other contrib
 * modules. This can be necessary to override dpl module functionality.
 */
function kdb_cludo_module_implements_alter(array &$implementations, string $hook): void {
  $target_hooks = [
    // To make sure that our custom Cludo search header shows up.
    'template_preprocess_page',
    // Alter the link shown on material search.
    'template_preprocess_dpl_react_app',
  ];

  if (!in_array($hook, $target_hooks)) {
    return;
  }

  // Move our hook implementation to the bottom of the list, to run last.
  $group = $implementations['kdb_cludo'];
  unset($implementations['kdb_cludo']);
  $implementations['kdb_cludo'] = $group;
}
